1. Design Primary contract:
- Objective, variables and functions purpose
2. Write the contract in Solidity
3. Create the Factory contract that allow us to create multiple instances
of the primary contract from the user perspective

4.Project setup:
Inside of our bet directory
-npm init
-npm install --save ganache-cli mocha solc fs-extra web3@1.0.0-beta.26
Updated command (the one I ran):
-npm install --save ganache-cli mocha solc@0.4.17 fs-extra web3@1.3.5

5. Project folder restructuring:
Inside of our bet directory, I create an ethereum folder.
Inside of the ethereum folder , I create a compile.js file, a deploy. js file
and an extra folder: contracts
Inside of the contracts folder, I move the Bet.sol file

6.Compiling.
Inside of our ethereum folder , we are creating a build folder.
Our compile.js file will be ran only once.
It will:
- delete everything in the build folder
- read Bet.sol from the contracts folder
- Compile both Factory and Bet contracts with solc@04.17
- Write output to the build folder

6b. Now we wrote our compile.js file,we can:
- cd etheureum
- node compile.js
To test our compiler


7. Test file setup

-New folder creation
-Setup the test file:
  -import 'require' assert module, gananche-cli module (local test network),
   web3 library
  and we create a new instance of web3 to which we plug the ganache provider.
  We also get the compiled contracts from the build directory.
  Then, we pass those compiled contracts -JSON parsed- to the 'new web3.eth.Contract()'
  And we access the functions within that contract via the .methods property
  We access the address via the options.address property
- We then write the tests with a beforeEach at the beginning that creates
for us the contracts instances to test,
- then in package.json we edit the 'test' line with 'test':'mocha'
-then we can go to the cd bet directory and run 'npm run test' to see if first tests
works fine
- Then we can actually keep on going with the tests


7b. Implement all deemed necessary tests


-----
Challenges:
- Add the requirements to every possible value transfer

- Everytime the contract balance is being altered
And keep track of the balance thanks to a contractBalance variable being
updated everytime there is a possible change on the contract balance.

- In case of primary contract constructor being payable,
how to pass value from the Factory contract to the child/primary contract,
see line address newBet=(new Bet).value(msg.value)(desc, valueStaked,msg.sender);


- To set up the bet instance , we had to provide money, so we discovered a newBet
parameter in the .send() from web3 - which is 'value'
ex: .send({ from: accounts[0], gas: "1000000", value: 1000000 });


- First test: I wanted to make sure the manager was acutally accounts[0].
So I just tried assert.equal(accounts[0], bet.methods.manager);

but the manager variable wasn't that easy to retrieve. Instead, I had to do
an async/await function before, like so:

it('sets the caller as the manager',async()=>{
manager=await bet.methods.manager().call()

assert.equal(accounts[0],manager);
})

What we learn: variables have to be called with () as well and inside of an
async await


- Tests expecting an error:
try{}
assert(false);
catch(e){assert(e);}

We explicitly assert(false) after the try catch in case, that line of code is ran,
 the whole test fails. Otherwise, catch the error and assert(e) makes sure that
 we do have an object error.
 We learn also that every 'it' block is independent of the others and a
 unique instance of 'bet' is being created for each 'it' block, due to the
 beforeEach block.

- To check an accounts balance: await web3.eth.getBalance(accounts[0])
