1. Design Primary contract:
- Objective, variables and functions purpose
2. Write the contract in Solidity
3. Create the Factory contract that allow us to create multiple instances
of the primary contract from the user perspective

4.Project setup:
Inside of our bet directory
-npm init
-npm install --save ganache-cli mocha solc fs-extra web3@1.0.0-beta.26
Updated command (the one I ran):
-npm install --save ganache-cli mocha solc@0.4.17 fs-extra web3@1.3.5

5. Project folder restructuring:
Inside of our bet directory, I create an ethereum folder.
Inside of the ethereum folder , I create a compile.js file, a deploy. js file
and an extra folder: contracts
Inside of the contracts folder, I move the Bet.sol file

6.Compiling.
Inside of our ethereum folder , we are creating a build folder.
Our compile.js file will be ran only once.
It will:
- delete everything in the build folder
- read Bet.sol from the contracts folder
- Compile both Factory and Bet contracts with solc@04.17
- Write output to the build folder

6b. Now we wrote our compile.js file,we can:
- cd etheureum
- node compile.js
To test our compiler


7. Test file setup





-----
Challenges:
- Add the requirements to every possible value transfer

- Everytime the contract balance is being altered
And keep track of the balance thanks to a contractBalance variable being
updated everytime there is a possible change on the contract balance.

- In case of primary contract constructor being payable,
how to pass value from the Factory contract to the child/primary contract,
see line address newBet=(new Bet).value(msg.value)(desc, valueStaked,msg.sender);
