1. Design Primary contract:
- Objective, variables and functions purpose
2. Write the contract in Solidity
3. Create the Factory contract that allow us to create multiple instances
of the primary contract from the user perspective

4.Project setup:
Inside of our bet directory
-npm init
-npm install --save ganache-cli mocha solc fs-extra web3@1.0.0-beta.26
Updated command (the one I ran):
-npm install --save ganache-cli mocha solc@0.4.17 fs-extra web3@1.3.5

5. Project folder restructuring:
Inside of our bet directory, I create an ethereum folder.
Inside of the ethereum folder , I create a compile.js file, a deploy. js file
and an extra folder: contracts
Inside of the contracts folder, I move the Bet.sol file

6.Compiling.
Inside of our ethereum folder , we are creating a build folder.
Our compile.js file will be ran only once.
It will:
- delete everything in the build folder
- read Bet.sol from the contracts folder
- Compile both Factory and Bet contracts with solc@04.17
- Write output to the build folder

6b. Now we wrote our compile.js file,we can:
- cd etheureum
- node compile.js
To test our compiler


7. Test file setup

-New folder creation
-Setup the test file:
  -import 'require' assert module, gananche-cli module (local test network),
   web3 library
  and we create a new instance of web3 to which we plug the ganache provider.
  We also get the compiled contracts from the build directory.
  Then, we pass those compiled contracts -JSON parsed- to the 'new web3.eth.Contract()'
  And we access the functions within that contract via the .methods property
  We access the address via the options.address property
- We then write the tests with a beforeEach at the beginning that creates
for us the contracts instances to test,
- then in package.json we edit the 'test' line with 'test':'mocha'
-then we can go to the cd bet directory and run 'npm run test' to see if first tests
works fine
- Then we can actually keep on going with the tests


7b. Implement all deemed necessary tests - questions arised on gasUsed - see Challenges

8. Deployment
- bet directory: we npm install --save truffle-hdwallet-provider@0.0.3
- In our deployment script, we'll require: const HDWalletProvider = require("truffle-hdwallet-provider");
- We setup the new provider:' const provider = new HDWalletProvider(
  "satoshi frozen ....'
- And we create a new function const deploy = async () => { in which Ill save the
variable 'accounts','result' with the result of the contract deployed
and we make sure to console.log the address of the contract deployed:
console.log("Contract deployed to", result.options.address);
-Then we cd etheureum and run 'node deploy.js'

****address of my deployed contract to the Rinkeby network : 0x2bcA21280148Dbe49860194e76780B0fb148AA8A*****


Then: web application to build around it.

9. Front end Setup

9a.Web mockup + route structure:
/: List of bets
/bets/new: Form to make a new bet
/bets/0x847: Bet details for bet at address ...

- We'll use Next.js
Inside our bet directory:
  -cli:sudo npm install -g create-react-app
  -npm install next react react-dom

- Inside of our project directory 'bet', we create a new folder: 'pages'
Every .js file we place within that folder will be turned into a
visitable web page

- As an example, we create two .js files within pages folder with:
import React from 'react'
export default ()=>{
return <h1> This is a new page <h1>
}

In both files with a different h1, then inside of package.json,we add a new line
in 'scripts':{
"test":"mocha",
"dev":"next dev"
}

- This will allow us to run the command: npm run dev. ( See challenges in case we got stuck)




-----
Challenges:
- Add the requirements to every possible value transfer

- Everytime the contract balance is being altered
And keep track of the balance thanks to a contractBalance variable being
updated everytime there is a possible change on the contract balance.

- In case of primary contract constructor being payable,
how to pass value from the Factory contract to the child/primary contract,
see line address newBet=(new Bet).value(msg.value)(desc, valueStaked,msg.sender);


- To set up the bet instance , we had to provide money, so we discovered a newBet
parameter in the .send() from web3 - which is 'value'
ex: .send({ from: accounts[0], gas: "1000000", value: 1000000 });


- First test: I wanted to make sure the manager was acutally accounts[0].
So I just tried assert.equal(accounts[0], bet.methods.manager);

but the manager variable wasn't that easy to retrieve. Instead, I had to do
an async/await function before, like so:

it('sets the caller as the manager',async()=>{
manager=await bet.methods.manager().call()

assert.equal(accounts[0],manager);
})

What we learn: variables have to be called with () as well and inside of an
async await


- Tests expecting an error:
try{}
assert(false);
catch(e){assert(e);}

We explicitly assert(false) after the try catch in case, that line of code is ran,
 the whole test fails. Otherwise, catch the error and assert(e) makes sure that
 we do have an object error.
 We learn also that every 'it' block is independent of the others and a
 unique instance of 'bet' is being created for each 'it' block, due to the
 beforeEach block.

- To check an accounts balance: await web3.eth.getBalance(accounts[0])

-assert(false) doesnt seem to fail my test

- The real assert to check equality for numbers, should have been

assert(posteriorManagerBalance === priorManagerBalance + contractBalance);

But this will always fail due to the gas spent

On gasUsed by a transaction, we can get access to this variable via
getTransactionReceipt from a transaction and view the transactionHash property/key
of that object

example:

txn = await bet.methods
  .isManageRight(false)
  .send({ from: accounts[0], gas: "1000000" });

receipt = await web3.eth.getTransactionReceipt(txn.transactionHash);
console.log(receipt.gasUsed);

********To do: work out the exact balances taking into account gasUsed*******


FRONT END


- Challenge while trying running npm run dev :Error: ENOSPC: System limit for number of file watchers reached
The error ENOSPC means that your hard drive is full.
This command fixed it before running npm run dev:
echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p
